# ProjetMalware


![alt text](https://github.com/Appash78/ProjetMalware/blob/main/Malware.jpg)

### Nous vous informons que certains de nos codes ne sont pas forcément fonctionnel 
 #### Explication
Ce TP a été réalisé par Lucas Bouyer, Vincent Bouyer et Martin Sauze.

-----


### Utilisation des scripts

Pour utiliser les scripts que nous avons réalisés :  

![Client.py](https://github.com/Appash78/ProjetMalware/blob/main/Client.py)

Le script client sert à la connection serveur.

![Serveur.py](https://github.com/Appash78/ProjetMalware/blob/main/Serveur.py)

Le script serveur permet de recevoir les informations du client

Les deux scripts permettent de communiquer entre eux. Voici en exemple en image : 

![alt text](https://github.com/Appash78/ProjetMalware/blob/main/Capture1.JPG)
![alt text](https://github.com/Appash78/ProjetMalware/blob/main/Capture2.JPG)

Ensuite nous avons le code Manage.py : 

![Manage.py](https://github.com/Appash78/ProjetMalware/blob/main/Manage.py)

Ce code est écrit en utilisant le framework Flask pour Python. Il utilise également une extension de Flask appelée Flask-SQLAlchemy pour intégrer une base de données à l'application. Utilisation de SQLModleCore pour créer des modèles de base de données pour des agents et des commandes.

La fonction name est utilisée pour générer un nom aléatoire unique à l'aide de lettres minuscules. La fonction user et >>user_vide utilisent cette fonction pour créer un nouvel agent dans la table Agent de la base de données en utilisant les paramètres spécifiés. La fonction ordre est utilisée pour créer une nouvelle commande dans la table Commands de la base de données en utilisant les paramètres spécifiés.

La fonction **user_list** affiche et retourne la liste de tous les agents dans la table **Agent de la base de données**, triés par **id**. La fonction get_ordre retourne la première commande non effectuée dans la table Commands de la base de données pour l'agent spécifié. Si l'agent ou la commande n'est pas trouvé, une chaîne de caractères appropriée est renvoyée.
La fonction **all_ordre_user** retourne une liste de toutes les commandes d'un utilisateur donné, avec un état spécifique **"todo"** ou **"done"**.

Au début du code, Il y a une vérification sur la présence de "redTeam.db" dans un dossier appelé "register" si elle n'est pas présente, il crée toutes les tables, sinon il imprime "rien" . Il utilise également la bibliothèque random pour générer des noms d'utilisateur uniques.

En résumé, c'est un script python qui utilise Flask et SQLAlchemy pour créer une application web avec une base de données qui gère les agents et les commandes, qui sont enregistrés dans des modèles de base de données et permettent de les afficher, de les ajouter, de les mettre à jour, et de les supprimer.



Passons maintenant à la dernière partie, le C2.

-----
**RAPPEL** : 
Un C2 (command and control) est un système ou une plateforme qui est utilisé pour contrôler et gérer les machines compromises dans un réseau informatique. Il permet à un attaquant de communiquer avec les ordinateurs compromis et de leur donner des instructions, comme exécuter des scripts malveillants, voler des informations sensibles, ou utiliser la puissance de calcul de la machine compromise pour effectuer des actions malveillantes supplémentaires.

Les systèmes C2 sont souvent utilisés dans les campagnes de piratage de type "APT" (Advanced Persistent Threat) pour maintenir un accès persistant à un réseau, et pour effectuer des actions discrètes pour éviter d'être détecté. Les attaquants peuvent utiliser des techniques de camouflage pour cacher les communications C2, comme utiliser des protocoles de communication courants, tels que HTTP ou HTTPS, pour se fondre dans le trafic réseau normal.

En résumé, les systèmes C2 servent pour les attaquants à maintenir une présence sur les ordinateurs compromis et les utiliser pour des actions malveillantes. Les administrateurs système et les analystes de sécurité peuvent utiliser des outils de détection de C2 pour identifier les machines compromise dans un réseau et pour suivre les activités malveillantes.

-----

Passons maintenant au code : 

![C2.py](https://github.com/Appash78/ProjetMalware/blob/main/C2.py)

Ce code est un exemple d'un serveur de commande et de contrôle (C2) qui utilise Flask, une bibliothèque Python pour développer des applications web, et SQLAlchemy, une bibliothèque qui facilite l'intégration d'une base de données à l'application. Il utilise également la bibliothèque requests pour envoyer et recevoir des données via des requêtes HTTP.

Il utilise Flask pour créer une application web qui écoute les requêtes HTTP sur différentes URL (routes). Les principales fonctions sont :

    create_agent : crée un nouvel agent dans la table Agent de la base de données en utilisant les paramètres spécifiés (nom, ordre et OS) et renvoie un ID d'agent.
    
    create_order : ajoute un ordre à l'agent spécifié dans la base de données.
    
    register : enregistre un agent en utilisant les fonctions create_agent et create_order pour ajouter un nouvel agent et un ordre à la base de données. Cette fonction est appelée lorsque une requête HTTP POST est reçue à l'URL '/register/'.
    
    add_command : ajoute une commande pour l'agent spécifié en utilisant les paramètres spécifiés (ID d'agent et commande) dans la table Commands de la base de données. Cette fonction est appelée lorsque une requête HTTP POST est reçue à l'URL '/add_Command/'.

En résumé, ce script est un serveur de commande et de contrôle (C2) qui utilise Flask, SQLAlchemy et requests pour créer une application web qui écoute les requêtes HTTP pour enregistrer et gérer les agents compromis et les commandes à distance via une base de données SQLite. Il peut servir de base pour une application malveillante qui utilise une infrastructure C2 pour contrôler à distance un groupe d'appareils compromis.


